// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file SensorOpticalFlow.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "SensorOpticalFlow.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>








px4_msgs::msg::SensorOpticalFlow::SensorOpticalFlow()
{
    // m_timestamp com.eprosima.idl.parser.typecode.PrimitiveTypeCode@242b836
    m_timestamp = 0;
    // m_timestamp_sample com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3f6f6701
    m_timestamp_sample = 0;
    // m_device_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3527942a
    m_device_id = 0;
    // m_pixel_flow com.eprosima.idl.parser.typecode.AliasTypeCode@942a29c
    memset(&m_pixel_flow, 0, (2) * 4);
    // m_delta_angle com.eprosima.idl.parser.typecode.AliasTypeCode@1ed6388a
    memset(&m_delta_angle, 0, (3) * 4);
    // m_delta_angle_available com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5a45133e
    m_delta_angle_available = false;
    // m_distance_m com.eprosima.idl.parser.typecode.PrimitiveTypeCode@534a5a98
    m_distance_m = 0.0;
    // m_distance_available com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4f80542f
    m_distance_available = false;
    // m_integration_timespan_us com.eprosima.idl.parser.typecode.PrimitiveTypeCode@60bd273d
    m_integration_timespan_us = 0;
    // m_quality com.eprosima.idl.parser.typecode.PrimitiveTypeCode@121314f7
    m_quality = 0;
    // m_error_count com.eprosima.idl.parser.typecode.PrimitiveTypeCode@130c12b7
    m_error_count = 0;
    // m_max_flow_rate com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5e600dd5
    m_max_flow_rate = 0.0;
    // m_min_ground_distance com.eprosima.idl.parser.typecode.PrimitiveTypeCode@576d5deb
    m_min_ground_distance = 0.0;
    // m_max_ground_distance com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5d534f5d
    m_max_ground_distance = 0.0;
    // m_mode com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2e3967ea
    m_mode = 0;

}

px4_msgs::msg::SensorOpticalFlow::~SensorOpticalFlow()
{















}

px4_msgs::msg::SensorOpticalFlow::SensorOpticalFlow(const SensorOpticalFlow &x)
{
    m_timestamp = x.m_timestamp;
    m_timestamp_sample = x.m_timestamp_sample;
    m_device_id = x.m_device_id;
    m_pixel_flow = x.m_pixel_flow;
    m_delta_angle = x.m_delta_angle;
    m_delta_angle_available = x.m_delta_angle_available;
    m_distance_m = x.m_distance_m;
    m_distance_available = x.m_distance_available;
    m_integration_timespan_us = x.m_integration_timespan_us;
    m_quality = x.m_quality;
    m_error_count = x.m_error_count;
    m_max_flow_rate = x.m_max_flow_rate;
    m_min_ground_distance = x.m_min_ground_distance;
    m_max_ground_distance = x.m_max_ground_distance;
    m_mode = x.m_mode;
}

px4_msgs::msg::SensorOpticalFlow::SensorOpticalFlow(SensorOpticalFlow &&x)
{
    m_timestamp = x.m_timestamp;
    m_timestamp_sample = x.m_timestamp_sample;
    m_device_id = x.m_device_id;
    m_pixel_flow = std::move(x.m_pixel_flow);
    m_delta_angle = std::move(x.m_delta_angle);
    m_delta_angle_available = x.m_delta_angle_available;
    m_distance_m = x.m_distance_m;
    m_distance_available = x.m_distance_available;
    m_integration_timespan_us = x.m_integration_timespan_us;
    m_quality = x.m_quality;
    m_error_count = x.m_error_count;
    m_max_flow_rate = x.m_max_flow_rate;
    m_min_ground_distance = x.m_min_ground_distance;
    m_max_ground_distance = x.m_max_ground_distance;
    m_mode = x.m_mode;
}

px4_msgs::msg::SensorOpticalFlow& px4_msgs::msg::SensorOpticalFlow::operator=(const SensorOpticalFlow &x)
{

    m_timestamp = x.m_timestamp;
    m_timestamp_sample = x.m_timestamp_sample;
    m_device_id = x.m_device_id;
    m_pixel_flow = x.m_pixel_flow;
    m_delta_angle = x.m_delta_angle;
    m_delta_angle_available = x.m_delta_angle_available;
    m_distance_m = x.m_distance_m;
    m_distance_available = x.m_distance_available;
    m_integration_timespan_us = x.m_integration_timespan_us;
    m_quality = x.m_quality;
    m_error_count = x.m_error_count;
    m_max_flow_rate = x.m_max_flow_rate;
    m_min_ground_distance = x.m_min_ground_distance;
    m_max_ground_distance = x.m_max_ground_distance;
    m_mode = x.m_mode;

    return *this;
}

px4_msgs::msg::SensorOpticalFlow& px4_msgs::msg::SensorOpticalFlow::operator=(SensorOpticalFlow &&x)
{

    m_timestamp = x.m_timestamp;
    m_timestamp_sample = x.m_timestamp_sample;
    m_device_id = x.m_device_id;
    m_pixel_flow = std::move(x.m_pixel_flow);
    m_delta_angle = std::move(x.m_delta_angle);
    m_delta_angle_available = x.m_delta_angle_available;
    m_distance_m = x.m_distance_m;
    m_distance_available = x.m_distance_available;
    m_integration_timespan_us = x.m_integration_timespan_us;
    m_quality = x.m_quality;
    m_error_count = x.m_error_count;
    m_max_flow_rate = x.m_max_flow_rate;
    m_min_ground_distance = x.m_min_ground_distance;
    m_max_ground_distance = x.m_max_ground_distance;
    m_mode = x.m_mode;

    return *this;
}

size_t px4_msgs::msg::SensorOpticalFlow::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ((2) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ((3) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t px4_msgs::msg::SensorOpticalFlow::getCdrSerializedSize(const px4_msgs::msg::SensorOpticalFlow& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    if ((2) > 0)
    {
        current_alignment += ((2) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }

    if ((3) > 0)
    {
        current_alignment += ((3) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void px4_msgs::msg::SensorOpticalFlow::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_timestamp;
    scdr << m_timestamp_sample;
    scdr << m_device_id;
    scdr << m_pixel_flow;

    scdr << m_delta_angle;

    scdr << m_delta_angle_available;
    scdr << m_distance_m;
    scdr << m_distance_available;
    scdr << m_integration_timespan_us;
    scdr << m_quality;
    scdr << m_error_count;
    scdr << m_max_flow_rate;
    scdr << m_min_ground_distance;
    scdr << m_max_ground_distance;
    scdr << m_mode;
}

void px4_msgs::msg::SensorOpticalFlow::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_timestamp;
    dcdr >> m_timestamp_sample;
    dcdr >> m_device_id;
    dcdr >> m_pixel_flow;

    dcdr >> m_delta_angle;

    dcdr >> m_delta_angle_available;
    dcdr >> m_distance_m;
    dcdr >> m_distance_available;
    dcdr >> m_integration_timespan_us;
    dcdr >> m_quality;
    dcdr >> m_error_count;
    dcdr >> m_max_flow_rate;
    dcdr >> m_min_ground_distance;
    dcdr >> m_max_ground_distance;
    dcdr >> m_mode;
}

/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void px4_msgs::msg::SensorOpticalFlow::timestamp(uint64_t _timestamp)
{
m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
uint64_t px4_msgs::msg::SensorOpticalFlow::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
uint64_t& px4_msgs::msg::SensorOpticalFlow::timestamp()
{
    return m_timestamp;
}

/*!
 * @brief This function sets a value in member timestamp_sample
 * @param _timestamp_sample New value for member timestamp_sample
 */
void px4_msgs::msg::SensorOpticalFlow::timestamp_sample(uint64_t _timestamp_sample)
{
m_timestamp_sample = _timestamp_sample;
}

/*!
 * @brief This function returns the value of member timestamp_sample
 * @return Value of member timestamp_sample
 */
uint64_t px4_msgs::msg::SensorOpticalFlow::timestamp_sample() const
{
    return m_timestamp_sample;
}

/*!
 * @brief This function returns a reference to member timestamp_sample
 * @return Reference to member timestamp_sample
 */
uint64_t& px4_msgs::msg::SensorOpticalFlow::timestamp_sample()
{
    return m_timestamp_sample;
}

/*!
 * @brief This function sets a value in member device_id
 * @param _device_id New value for member device_id
 */
void px4_msgs::msg::SensorOpticalFlow::device_id(uint32_t _device_id)
{
m_device_id = _device_id;
}

/*!
 * @brief This function returns the value of member device_id
 * @return Value of member device_id
 */
uint32_t px4_msgs::msg::SensorOpticalFlow::device_id() const
{
    return m_device_id;
}

/*!
 * @brief This function returns a reference to member device_id
 * @return Reference to member device_id
 */
uint32_t& px4_msgs::msg::SensorOpticalFlow::device_id()
{
    return m_device_id;
}

/*!
 * @brief This function copies the value in member pixel_flow
 * @param _pixel_flow New value to be copied in member pixel_flow
 */
void px4_msgs::msg::SensorOpticalFlow::pixel_flow(const px4_msgs::msg::float__2 &_pixel_flow)
{
m_pixel_flow = _pixel_flow;
}

/*!
 * @brief This function moves the value in member pixel_flow
 * @param _pixel_flow New value to be moved in member pixel_flow
 */
void px4_msgs::msg::SensorOpticalFlow::pixel_flow(px4_msgs::msg::float__2 &&_pixel_flow)
{
m_pixel_flow = std::move(_pixel_flow);
}

/*!
 * @brief This function returns a constant reference to member pixel_flow
 * @return Constant reference to member pixel_flow
 */
const px4_msgs::msg::float__2& px4_msgs::msg::SensorOpticalFlow::pixel_flow() const
{
    return m_pixel_flow;
}

/*!
 * @brief This function returns a reference to member pixel_flow
 * @return Reference to member pixel_flow
 */
px4_msgs::msg::float__2& px4_msgs::msg::SensorOpticalFlow::pixel_flow()
{
    return m_pixel_flow;
}
/*!
 * @brief This function copies the value in member delta_angle
 * @param _delta_angle New value to be copied in member delta_angle
 */
void px4_msgs::msg::SensorOpticalFlow::delta_angle(const px4_msgs::msg::float__3 &_delta_angle)
{
m_delta_angle = _delta_angle;
}

/*!
 * @brief This function moves the value in member delta_angle
 * @param _delta_angle New value to be moved in member delta_angle
 */
void px4_msgs::msg::SensorOpticalFlow::delta_angle(px4_msgs::msg::float__3 &&_delta_angle)
{
m_delta_angle = std::move(_delta_angle);
}

/*!
 * @brief This function returns a constant reference to member delta_angle
 * @return Constant reference to member delta_angle
 */
const px4_msgs::msg::float__3& px4_msgs::msg::SensorOpticalFlow::delta_angle() const
{
    return m_delta_angle;
}

/*!
 * @brief This function returns a reference to member delta_angle
 * @return Reference to member delta_angle
 */
px4_msgs::msg::float__3& px4_msgs::msg::SensorOpticalFlow::delta_angle()
{
    return m_delta_angle;
}
/*!
 * @brief This function sets a value in member delta_angle_available
 * @param _delta_angle_available New value for member delta_angle_available
 */
void px4_msgs::msg::SensorOpticalFlow::delta_angle_available(bool _delta_angle_available)
{
m_delta_angle_available = _delta_angle_available;
}

/*!
 * @brief This function returns the value of member delta_angle_available
 * @return Value of member delta_angle_available
 */
bool px4_msgs::msg::SensorOpticalFlow::delta_angle_available() const
{
    return m_delta_angle_available;
}

/*!
 * @brief This function returns a reference to member delta_angle_available
 * @return Reference to member delta_angle_available
 */
bool& px4_msgs::msg::SensorOpticalFlow::delta_angle_available()
{
    return m_delta_angle_available;
}

/*!
 * @brief This function sets a value in member distance_m
 * @param _distance_m New value for member distance_m
 */
void px4_msgs::msg::SensorOpticalFlow::distance_m(float _distance_m)
{
m_distance_m = _distance_m;
}

/*!
 * @brief This function returns the value of member distance_m
 * @return Value of member distance_m
 */
float px4_msgs::msg::SensorOpticalFlow::distance_m() const
{
    return m_distance_m;
}

/*!
 * @brief This function returns a reference to member distance_m
 * @return Reference to member distance_m
 */
float& px4_msgs::msg::SensorOpticalFlow::distance_m()
{
    return m_distance_m;
}

/*!
 * @brief This function sets a value in member distance_available
 * @param _distance_available New value for member distance_available
 */
void px4_msgs::msg::SensorOpticalFlow::distance_available(bool _distance_available)
{
m_distance_available = _distance_available;
}

/*!
 * @brief This function returns the value of member distance_available
 * @return Value of member distance_available
 */
bool px4_msgs::msg::SensorOpticalFlow::distance_available() const
{
    return m_distance_available;
}

/*!
 * @brief This function returns a reference to member distance_available
 * @return Reference to member distance_available
 */
bool& px4_msgs::msg::SensorOpticalFlow::distance_available()
{
    return m_distance_available;
}

/*!
 * @brief This function sets a value in member integration_timespan_us
 * @param _integration_timespan_us New value for member integration_timespan_us
 */
void px4_msgs::msg::SensorOpticalFlow::integration_timespan_us(uint32_t _integration_timespan_us)
{
m_integration_timespan_us = _integration_timespan_us;
}

/*!
 * @brief This function returns the value of member integration_timespan_us
 * @return Value of member integration_timespan_us
 */
uint32_t px4_msgs::msg::SensorOpticalFlow::integration_timespan_us() const
{
    return m_integration_timespan_us;
}

/*!
 * @brief This function returns a reference to member integration_timespan_us
 * @return Reference to member integration_timespan_us
 */
uint32_t& px4_msgs::msg::SensorOpticalFlow::integration_timespan_us()
{
    return m_integration_timespan_us;
}

/*!
 * @brief This function sets a value in member quality
 * @param _quality New value for member quality
 */
void px4_msgs::msg::SensorOpticalFlow::quality(uint8_t _quality)
{
m_quality = _quality;
}

/*!
 * @brief This function returns the value of member quality
 * @return Value of member quality
 */
uint8_t px4_msgs::msg::SensorOpticalFlow::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
uint8_t& px4_msgs::msg::SensorOpticalFlow::quality()
{
    return m_quality;
}

/*!
 * @brief This function sets a value in member error_count
 * @param _error_count New value for member error_count
 */
void px4_msgs::msg::SensorOpticalFlow::error_count(uint32_t _error_count)
{
m_error_count = _error_count;
}

/*!
 * @brief This function returns the value of member error_count
 * @return Value of member error_count
 */
uint32_t px4_msgs::msg::SensorOpticalFlow::error_count() const
{
    return m_error_count;
}

/*!
 * @brief This function returns a reference to member error_count
 * @return Reference to member error_count
 */
uint32_t& px4_msgs::msg::SensorOpticalFlow::error_count()
{
    return m_error_count;
}

/*!
 * @brief This function sets a value in member max_flow_rate
 * @param _max_flow_rate New value for member max_flow_rate
 */
void px4_msgs::msg::SensorOpticalFlow::max_flow_rate(float _max_flow_rate)
{
m_max_flow_rate = _max_flow_rate;
}

/*!
 * @brief This function returns the value of member max_flow_rate
 * @return Value of member max_flow_rate
 */
float px4_msgs::msg::SensorOpticalFlow::max_flow_rate() const
{
    return m_max_flow_rate;
}

/*!
 * @brief This function returns a reference to member max_flow_rate
 * @return Reference to member max_flow_rate
 */
float& px4_msgs::msg::SensorOpticalFlow::max_flow_rate()
{
    return m_max_flow_rate;
}

/*!
 * @brief This function sets a value in member min_ground_distance
 * @param _min_ground_distance New value for member min_ground_distance
 */
void px4_msgs::msg::SensorOpticalFlow::min_ground_distance(float _min_ground_distance)
{
m_min_ground_distance = _min_ground_distance;
}

/*!
 * @brief This function returns the value of member min_ground_distance
 * @return Value of member min_ground_distance
 */
float px4_msgs::msg::SensorOpticalFlow::min_ground_distance() const
{
    return m_min_ground_distance;
}

/*!
 * @brief This function returns a reference to member min_ground_distance
 * @return Reference to member min_ground_distance
 */
float& px4_msgs::msg::SensorOpticalFlow::min_ground_distance()
{
    return m_min_ground_distance;
}

/*!
 * @brief This function sets a value in member max_ground_distance
 * @param _max_ground_distance New value for member max_ground_distance
 */
void px4_msgs::msg::SensorOpticalFlow::max_ground_distance(float _max_ground_distance)
{
m_max_ground_distance = _max_ground_distance;
}

/*!
 * @brief This function returns the value of member max_ground_distance
 * @return Value of member max_ground_distance
 */
float px4_msgs::msg::SensorOpticalFlow::max_ground_distance() const
{
    return m_max_ground_distance;
}

/*!
 * @brief This function returns a reference to member max_ground_distance
 * @return Reference to member max_ground_distance
 */
float& px4_msgs::msg::SensorOpticalFlow::max_ground_distance()
{
    return m_max_ground_distance;
}

/*!
 * @brief This function sets a value in member mode
 * @param _mode New value for member mode
 */
void px4_msgs::msg::SensorOpticalFlow::mode(uint8_t _mode)
{
m_mode = _mode;
}

/*!
 * @brief This function returns the value of member mode
 * @return Value of member mode
 */
uint8_t px4_msgs::msg::SensorOpticalFlow::mode() const
{
    return m_mode;
}

/*!
 * @brief This function returns a reference to member mode
 * @return Reference to member mode
 */
uint8_t& px4_msgs::msg::SensorOpticalFlow::mode()
{
    return m_mode;
}


size_t px4_msgs::msg::SensorOpticalFlow::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;


















    return current_align;
}

bool px4_msgs::msg::SensorOpticalFlow::isKeyDefined()
{
   return false;
}

void px4_msgs::msg::SensorOpticalFlow::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
}


